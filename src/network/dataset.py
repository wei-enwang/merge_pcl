import torch
import json
import pickle
from torch.utils.data import Dataset
import numpy as np


class rgbd_data(Dataset):
    """
    Class for pybullet rgbd images. 

    Args:
        data_paths:
            directories of the saved images
        transform (a function or a list of functions):
            transform(s) applied to features (x)

    """

    def __init__(self, data_paths, latent_paths, seq_len=10, transform=None, idx_mask=None):

        self.data_paths = data_paths
        self.latent_paths = latent_paths
        self.seq_len = seq_len
        self.transform = transform
        # TODO: replace the following with the latents generated by occupancy network
        self.gt_latents_dict = json.load('../data/latents/trial_latents.json')
        # For our ease of implementation, suppose number of images is divisible by the length of sequences
        assert len(data_paths) % seq_len == 0
        self.idxs = np.arange(len(data_paths)).reshape((-1,seq_len))
        if idx_mask:
            self.idxs = self.idxs[idx_mask,:]

    def __len__(self):
        assert len(self.data_paths) == len(self.latent_paths)
        return len(self.idxs)

    def __getitem__(self, idx):

        img_seq = []
        gt_latents_seq = []
        for i in self.idxs[idx,:]:
            img_path = self.data_paths[i]
            # Apply transform to image
            img = self.transform(np.load(img_path))
            img_seq.append(img)
        
            latents = self.latent_paths[i]  
            gt_latent = []   
            for l in pickle.load(latents):
                gt_latent.append(self.gt_latents_dict[l])
            gt_latents_seq.append(gt_latent)

        img_seq, gt_latents_seq = torch.FloatTensor(img_seq), torch.FloatTensor(gt_latents_seq)
        return img_seq, gt_latents_seq

